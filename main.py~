import os
from espeak import espeak
from tkinter import *
from bs4 import BeautifulSoup
import tkinter as tk
import urllib
import re, collections
import pickle


lis=map(chr,range(97,123))
lis=list(lis)
lis.append("'")

class TrieNode:
    def __init__(self):
        self.val = None
        self.pointers={}
        self.end=0


class Trie:

    def __init__(self):
        self.root = TrieNode()

    def insert(self, word):
        self.rec_insert(word, self.root)
        return

    def rec_insert(self, word, node):
        if word[:1] not in node.pointers:
            newNode=TrieNode()
            newNode.val=word[:1]
            node.pointers[word[:1]]=newNode
            self.rec_insert(word, node)
        else:
            nextNode = node.pointers[word[:1]]
            if len(word[1:])==0:
                node.end=1
                return
            return self.rec_insert(word[1:], nextNode)

    def search(self, word):
        if len(word)==0:
            return False
        return self.rec_search(word,self.root)

    def rec_search(self, word, node):
        if word[:1] not in node.pointers:
            return False
        else:
            nextNode = node.pointers[word[:1]]
            if len(word[1:])==0:
                if nextNode.end == 1:
                    return True
                else:
                    return False
            return self.rec_search(word[1:],nextNode)

    def startsWith(self, prefix):
        if len(prefix)==0:
            return True
        return self.rec_search_prefix(prefix,self.root)

    def rec_search_prefix(self, word, node):
        if word[:1] not in node.pointers:
            return False
        else:
            if len(word[1:])==0:
                return True
            nextNode = node.pointers[word[:1]]
            return self.rec_search_prefix(word[1:],nextNode)
            
    
    def findAll(self,node,word,sugg):
    	for c in lis:
    		if c in node.pointers:
    			if node.pointers[c].end==1:
    				sugg.append(word+str(c))
    			self.findAll(node.pointers[c],word+str(c),sugg)
    	return
    	        

    def didUMean(self,word,sugg):
    	if self.startsWith(word):
    		top=self.root
    		for c in word:
    			top=top.pointers[c]
    		self.findAll(top,word,sugg)
    	else:
    		return
    	         

'''
trie=Trie()

file = open('words.txt','r')
dict=file.readlines()
for words in dict:
	trie.insert(words.lower())
file.close()

pickle.dump(trie,open("save.p", "wb"))
'''

trie = pickle.load(open( "save.p", "rb"))

class EditDist:
	def __init__(self):
		pass

def words(text): return re.findall('[a-z]+', text.lower()) 

def train():
    model = collections.defaultdict(lambda: 1)
    file = open('words.txt','r')
    dict=file.readlines()  
    
    for f in dict:
        model[f.lower()]+=1
    return model

NWORDS = train()

alphabet = "abcdefghijklmnopqrstuvwxyz'"

def edits1(word):
   splits     = [(word[:i], word[i:]) for i in range(len(word) + 1)]
   deletes    = [a + b[1:] for a, b in splits if b]
   transposes = [a + b[1] + b[0] + b[2:] for a, b in splits if len(b)>1]
   replaces   = [a + c + b[1:] for a, b in splits for c in alphabet if b]
   inserts    = [a + c + b     for a, b in splits for c in alphabet]
   return set(deletes + transposes + replaces + inserts)

def known_edits2(word):
    return set(e2 for e1 in edits1(word) for e2 in edits1(e1) if e2 in NWORDS)

def known(words): return set(w for w in words if w in NWORDS)

def correct(word):
    candidates = known([word]) or known(edits1(word)) or known_edits2(word) or [word]
    return max(candidates, key=NWORDS.get)	

while True:

	word= input("Enter the word:")
	word=word.lower()
	os.system('espeak -s 120 '+word)
	if word=='exit':
		break

	if trie.search(word):
		print("Found")
		urlStr='http://www.dictionary.com/browse/'+word+'?s=t'
		url=urllib.request.urlopen(urlStr)
		content = url.read()
		soup = BeautifulSoup(content)
		for script in soup(["script", "style"]):
		    script.extract()
		text = soup.get_text()
		lines = (line.strip() for line in text.splitlines())
		chunks = (phrase.strip() for line in lines for phrase in line.split("  "))
		res=[chunk for chunk in chunks if chunk]

		try:
			res=res[res.index('Share')+1:]
			res=res[res.index('Share')+1:]
		except ValueError:
			pass
		
		try:
			res=res[:res.index('About')]
		except ValueError:
			pass
		
		try:
			nearbyInd=res.index('Nearby words for '+word)
			nearbyWords=res[nearbyInd:]
			res=res[:nearbyInd]
		except ValueError:
			pass	
		
		try:
			relatedInd=res.index('Related Words')
			relatedWords=res[relatedInd:]
			res=res[:relatedInd]
		except ValueError:
			pass
			
		try:
			res=res[:res.index('Word Value for '+word)]
		except ValueError:
			pass
			
		try:
			difficulty=res[-1]
			res=res[:-5]
		except ValueError:
			pass				
		
		for i in range(len(res)):
			print(i,res[i])
		text = '\n'.join(chunk for chunk in chunks if chunk)

		#print(text)
		
	else:
		print("Not Found\nDid You Mean:")
		os.system("espeak -s 120 'Not Found. Did You Mean:'")
		sugg=[]
		trie.didUMean(word,sugg)
		sugg.sort(key = lambda s: len(s))
		for words in sugg[:min(len(sugg),10)]:
			print(words)
			os.system('espeak -s 120 '+words)
		

root = Tk()
entry = Entry(root, width=10)
entry.pack()
soundIcon = PhotoImage(file='soundIcon.png')
root.mainloop()
      
